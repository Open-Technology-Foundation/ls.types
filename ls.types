#!/usr/bin/env bash
# ls.types - List script files by shebang or extension
#
# Symlink dispatch: behavior determined by invocation name ($TYPE_NAME)
# Config format: symlink:filetype:shebang_pattern:extensions (colon-delimited)
# Example: lsb:Bash:bash:sh,bash
#
# Key vars: SCRIPT_NAME (canonical), TYPE_NAME (symlink), EXT[] (extensions)
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

declare -r VERSION=1.1.0
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*}
declare -r SCRIPT_NAME=${SCRIPT_PATH##*/}

declare -r TYPE_NAME=${0##*/}  # Symlink name determines behavior

error() { >&2 echo "$SCRIPT_NAME: $TYPE_NAME: error: $*"; }
die() { (($# < 2)) || error "${@:2}"; exit "${1:-0}"; }

# head1 - Return first line from file (much faster than head -n 1)
head1() {
  # synopsis: head1 [FILE]|<stdin
  local -a MAPFILE
  if (($#)); then
    # If a filename is provided, read from the file
    mapfile -t -n 1 < "$1"
  else
    # If no filename is provided, read from stdin
    mapfile -t -n 1
  fi
  ((${#MAPFILE[@]}==0)) || printf '%s' "${MAPFILE[0]}"
}

declare -a DIRS=() LS_FILES=()
declare -i MAXDEPTH=1 REALPATH=0 LS=0

declare -- FILETYPE='' SHBANG=''
declare -Ai EXT=()

# Config file search paths (FHS order, script dir last for dev)
declare -a CONFIG_PATHS=(
  /etc/"$SCRIPT_NAME"/types.conf
  /usr/local/share/"$SCRIPT_NAME"/types.conf
  /usr/share/"$SCRIPT_NAME"/types.conf
  "$SCRIPT_DIR"/types.conf
)

# find_config: Return first readable config path, or fail
find_config() {
  local -- path
  for path in "${CONFIG_PATHS[@]}"; do
    #shellcheck disable=SC2015
    [[ -r "$path" ]] && { echo "$path"; return 0; } ||:
  done
  return 1
}

# edit_config: Interactive config editor with optional symlink creation
edit_config() {
  local -- config_file
  echo "Edit $SCRIPT_NAME config file:"
  echo
  select config_file in "${CONFIG_PATHS[@]}"; do
    [[ -n "$config_file" ]] || { error "Invalid selection ${config_file@Q}"; continue; }

    if [[ ! -f "$config_file" ]]; then
      mkdir -p "${config_file%/*}" 2>/dev/null || die 1 "Cannot create directory for ${config_file@Q}"
      touch "$config_file" 2>/dev/null || die 1 "Cannot create ${config_file@Q}"
    fi

    [[ -w "$config_file" ]] || die 1 "Cannot write to ${config_file@Q}"

    "${EDITOR:-nano}" "$config_file"
    echo
    break
  done

  read -r -p "Create symlinks in ${config_file@Q}? y/n "
  echo
  if [[ "${REPLY,,}" == y ]]; then
    CONFIG_FILE=$config_file
    manage_symlinks create
  fi

  exit
}

# manage_symlinks: List or create symlinks defined in config (action: list|create)
manage_symlinks() {
  local -- action=${1:-list} target_dir=${2:-$SCRIPT_DIR}
  local -a symlinks=()

  # Extract symlink names from config (first field before colon)
  readarray -t symlinks < <(
    grep -v '^[[:blank:]]*#\|^[[:blank:]]*$' "$CONFIG_FILE" | cut -d: -f1
  )

  if [[ $action == list ]]; then
    echo "Symlinks defined in $CONFIG_FILE:"
    for name in "${symlinks[@]}"; do
      if [[ -L "$SCRIPT_DIR/$name" ]]; then
        printf '  %-12s [exists]  -> %s\n' "$name" "$(realpath "$SCRIPT_DIR/$name")"
      else
        printf '  %-12s [missing]\n' "$name"
      fi
    done
  elif [[ $action == create ]]; then
    [[ -d "$target_dir" ]] || die 1 "Directory not found ${target_dir@Q}"
    for name in "${symlinks[@]}"; do
      [[ -e "$target_dir/$name" ]] && continue
      ln -s "$SCRIPT_PATH" "$target_dir/$name" && echo "Created '$target_dir/$name'"
    done
  else
    die 1 "Unknown action ${action@Q}. Use 'list' or 'create'"
  fi
}

# usage_generic: Help text when invoked directly (not via symlink)
usage_generic() {
  cat <<HELP
Usage: $SCRIPT_NAME [OPTIONS]
       <symlink> [OPTIONS] [DIR...]

List script files by shebang or extension using symlink dispatch.

Global Options:
  -E, --edit        Edit config file
  -S, --symlinks [ACTION] [DIR]
                    List or create symlinks (ACTION: list|create)
  -V, --version     Show version
  -h, --help        Show this help

Invoke via symlink for language-specific listing:
  ls.bash           Bash files (.sh, .bash)
  ls.python         Python files (.py)
  ls.php            PHP files (.php)

Current Symlinks:
$("$0" --symlinks list)

Examples:
  $SCRIPT_NAME -S list      # Show available symlinks
  lsb -h                    # Bash-specific help
  lsb -rl /scripts          # List Bash files with realpath + ls format
HELP
}

# Load config for this symlink name
declare -- CONFIG_FILE
CONFIG_FILE=$(find_config) || die 1 'No config file found'

# Handle global options before TYPE_NAME lookup
case ${1:-} in
  -E|--edit)     edit_config ;;
  -S|--symlinks) manage_symlinks "${2:-}" "${3:-}"; exit 0 ;;
esac

# Show generic help/version when invoked directly (not via symlink)
if [[ "$TYPE_NAME" == "$SCRIPT_NAME" ]]; then
  case ${1:-} in
    -V|--version) echo "$SCRIPT_NAME $VERSION"; exit 0 ;;
    -h|--help)    usage_generic; exit 0 ;;
    '')           >&2 usage_generic; exit 1 ;;
    *)            die 1 "Unknown symlink ${TYPE_NAME@Q}. Use -S list to see available symlinks" ;;
  esac
fi

declare -- config_line
config_line=$(grep -v '^[[:blank:]]*#\|^[[:blank:]]*$' "$CONFIG_FILE" \
  | grep "^${TYPE_NAME}:" \
  | head1) || die 1 "Unknown symlink ${TYPE_NAME@Q}. Edit ${CONFIG_FILE@Q}"

# Parse config: symlink:filetype:pattern:extensions
declare -- pattern extensions
IFS=':' read -r _ FILETYPE pattern extensions <<<"$config_line"
SHBANG="^#!.*${pattern}"  # Regex for shebang matching (e.g., ^#!.*bash)

# Build EXT associative array
declare -a ext_list
IFS=',' read -ra ext_list <<<"$extensions"
declare -- e
for e in "${ext_list[@]}"; do
  EXT[$e]=1
done

# usage: Help text for symlink invocation (includes type-specific info)
usage() {
  cat <<HELP
Usage: $TYPE_NAME [OPTIONS] [DIR...]

List $FILETYPE script files by shebang or extension (${!EXT[@]}).

Options:
  -d, --maxdepth N  Max find depth (default: 1)
  -r, --realpath    Output absolute paths
  -l, --ls          Output as ls -lhA listing
  -E, --edit        Edit $SCRIPT_NAME config file
  -S, --symlinks [ACTION] [DIR]
                    List or create symlinks (ACTION: list|create)
  -V, --version     Show version
  -h, --help        Show this help

$("$0" --symlinks list)

Examples:
  # Current dir, depth 1
  $TYPE_NAME
  # Depth 2 in /my/scripts
  $TYPE_NAME -d 2 /my/scripts
  # Realpath + ls listing
  $TYPE_NAME -rl .
  # Depth 1 in two dirs
  $TYPE_NAME --ls /my/scripts /my/backup
HELP
}

# --- Argument Parsing ---
while (($#)); do case $1 in
  -E|--edit)      edit_config ;;
  -S|--symlinks)  manage_symlinks "${2:-}" "${3:-}"; exit 0 ;;
  -V|--version)   echo "$TYPE_NAME $VERSION"; exit 0 ;;
  -h|--help)      usage; exit 0 ;;

  -r|--realpath)  REALPATH=1 ;;
  -l|--ls)        LS=1 ;;
  -d|--maxdepth)  MAXDEPTH=${2:-1}; shift ;;
  -[0123456789]*) MAXDEPTH=${1:1} ;;
  -[Vhrld]*)      # Expand clustered options: -rl -> -r -l
                  #shellcheck disable=SC2046
                  set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}" ;;
  -*)             die 22 "Unknown option ${1@Q}" ;;
  *)              DIRS+=("$1") ;;
esac; shift; done

((${#DIRS[@]})) || DIRS=(.)
declare -- dir
for dir in "${DIRS[@]}"; do
  [[ -d "$dir" ]] || die 1 "Not a directory ${dir@Q}"
done

# --- File Discovery ---
declare -a FILES=()
if ((REALPATH)); then
  readarray -t FILES < <(find -- "${DIRS[@]}" -maxdepth "$MAXDEPTH" -type f -exec realpath -e -- {} \; | sort -u)
else
  readarray -t FILES < <(find -- "${DIRS[@]}" -maxdepth "$MAXDEPTH" -type f | sort)
fi

# --- Filter and Output ---
declare -- file
for file in "${FILES[@]}"; do
  [[ -n "$file" ]] || continue
  [[ -r "$file" ]] || continue
  # Skip binary files (using file(1) MIME encoding detection)
  #shellcheck disable=SC2015
  [[ $(file -b --mime-encoding "$file") == binary ]] && continue ||:

  # Match by shebang first, fall back to extension
  [[ "$(head1 "$file")" =~ $SHBANG ]] || {
    [[ -v EXT[${file##*.}] ]] || continue
  }

  if ((LS)); then
    LS_FILES+=("$file")
  else
    printf '%s\n' "$file"
  fi
done

if ((LS && ${#LS_FILES[@]})); then
  /usr/bin/ls -lhA --color=always --time-style=long-iso "${LS_FILES[@]}"
fi

#fin
